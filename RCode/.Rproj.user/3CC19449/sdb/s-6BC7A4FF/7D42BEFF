{
    "contents" : "library(proto)\n\nstat_smooth_func <- function (mapping = NULL, data = NULL, geom = \"smooth\", position = \"identity\",\n                              method = \"auto\", formula = y ~ x, se = TRUE, n = 80, fullrange = FALSE,\n                              level = 0.95, na.rm = FALSE, ...) {\n  StatSmoothFunc$new(mapping = mapping, data = data, geom = geom, position = position,\n                     method = method, formula = formula, se = se, n = n, fullrange = fullrange,\n                     level = level, na.rm = na.rm, ...)\n}\n\nStatSmoothFunc <- proto(ggplot2:::Stat, {\n  objname <- \"smooth\"\n  \n  calculate_groups <- function(., data, scales, method=\"auto\", formula=y~x, ...) {\n    rows <- daply(data, .(group), function(df) length(unique(df$x)))\n    \n    if (all(rows == 1) && length(rows) > 1) {\n      message(\"geom_smooth: Only one unique x value each group.\",\n              \"Maybe you want aes(group = 1)?\")\n      return(data.frame())\n    }\n    \n    # Figure out what type of smoothing to do: loess for small datasets,\n    # gam with a cubic regression basis for large data\n    # This is based on the size of the _largest_ group.\n    if (identical(method, \"auto\")) {\n      groups <- count(data, \"group\")\n      \n      if (max(groups$freq) < 1000) {\n        method <- \"loess\"\n        message('geom_smooth: method=\"auto\" and size of largest group is <1000,',\n                ' so using loess.',\n                ' Use \\'method = x\\' to change the smoothing method.')\n      } else {\n        method <- \"gam\"\n        formula <- y ~ s(x, bs = \"cs\")\n        message('geom_smooth: method=\"auto\" and size of largest group is >=1000,',\n                ' so using gam with formula: y ~ s(x, bs = \"cs\").',\n                ' Use \\'method = x\\' to change the smoothing method.')\n      }\n    }\n    if (identical(method, \"gam\")) try_require(\"mgcv\")\n    \n    .super$calculate_groups(., data, scales, method = method, formula = formula, ...)\n  }\n  \n  calculate <- function(., data, scales, method=\"auto\", formula=y~x, se = TRUE, n=80, fullrange=FALSE, xseq = NULL, level=0.95, na.rm = FALSE, ...) {\n    data <- remove_missing(data, na.rm, c(\"x\", \"y\"), name=\"stat_smooth\")\n    if (length(unique(data$x)) < 2) {\n      # Not enough data to perform fit\n      return(data.frame())\n    }\n    \n    if (is.null(data$weight)) data$weight <- 1\n    \n    if (is.null(xseq)) {\n      if (is.integer(data$x)) {\n        if (fullrange) {\n          xseq <- scale_dimension(scales$x, c(0, 0))\n        } else {\n          xseq <- sort(unique(data$x))\n        }\n      } else {\n        if (fullrange) {\n          range <- scale_dimension(scales$x, c(0, 0))\n        } else {\n          range <- range(data$x, na.rm=TRUE)\n        }\n        xseq <- seq(range[1], range[2], length=n)\n      }\n    }\n    if (is.character(method)) method <- match.fun(method)\n    \n    method.special <- function(...)\n      method(formula, data=data, weights=weight, ...)\n    model <- safe.call(method.special, list(...), names(formals(method)))\n    \n    predictdf(model, xseq, se, level)\n    m = model\n    eq <- substitute(italic(y) == a + b %.% italic(x)*\",\"~~italic(r)^2~\"=\"~r2, \n                     list(a = format(coef(m)[1], digits = 3), \n                          b = format(coef(m)[2], digits = 3), \n                          r2 = format(summary(m)$r.squared, digits = 3)))\n    func_string = as.character(as.expression(eq))\n    \n    data.frame(x=min(data$x)*0.9, y=max(data$y)*0.9, label=func_string)\n  }\n  \n  required_aes <- c(\"x\", \"y\")\n  default_geom <- function(.) GeomSmooth\n})",
    "created" : 1426341056527.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1810635845",
    "id" : "7D42BEFF",
    "lastKnownWriteTime" : 1426359286,
    "path" : "~/MATLAB/NeurophysNRG/RCode/StatSmoothFunc.R",
    "project_path" : "StatSmoothFunc.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}